3.2. Project Initialization – Predictable Setup

**Principle:** Every project should start with a predictable, repeatable setup. Before a resource can be published, it must meet minimum requirements:
- Frontend from a proven template
- Backend from a proven template
- At least one working endpoint
- Dockerization enabling the entire environment to run with a single command (vibecoded)

### 3.2.1. Frontend - Angular from Template

**Install Angular CLI globally:**
```bash
npm install -g @angular/cli
```

**Create a new project:**
```bash
ng new uknf-project
```

During initialization, Angular CLI will ask about:
- Routing (whether to add Angular Router) - We selected **Yes**
- Style format (CSS, SCSS, SASS, LESS) - CSS (Tailwind documentation recommendation)

**Start the development server:**
```bash
cd frontend/uknf-project
ng serve
```

The application will be available by default at: `http://localhost:4200`

**Verification:**
- Check that the application starts without errors
- Open a browser and ensure you see the default Angular welcome screen
- Check console logs in the terminal - no compilation errors

**AI prompt for frontend configuration:**
```
"Initialize an Angular 20 project with the following requirements:
- Routing enabled
- SCSS as style preprocessor
- Strict mode enabled
- Standalone components as default
- Directory structure: features, shared, core
- Environment configuration for dev/prod
- ESLint + Prettier
- Generate basic layout with header, content, footer"
```

### 3.2.2. Backend - .NET from Template

**Install .NET SDK:**
```bash
# Windows (Chocolatey)
choco install dotnet-9.0-sdk

# macOS (Homebrew)
brew install --cask dotnet-sdk

# Linux (Ubuntu/Debian)
wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
chmod +x dotnet-install.sh
./dotnet-install.sh --channel 9.0
```

**Create Web API project:**
```bash
dotnet new webapi -n UknfCommunicationPlatform.Api
cd backend/UknfCommunicationPlatform.Api
```

**Solution structure:**
```bash
# Create solution
dotnet new sln -n UknfCommunicationPlatform

# Create projects
dotnet new webapi -n UknfCommunicationPlatform.Api
dotnet new classlib -n UknfCommunicationPlatform.Core
dotnet new classlib -n UknfCommunicationPlatform.Infrastructure
dotnet new xunit -n UknfCommunicationPlatform.Tests.Unit
dotnet new xunit -n UknfCommunicationPlatform.Tests.Integration

# Add projects to solution
dotnet sln add UknfCommunicationPlatform.Api
dotnet sln add UknfCommunicationPlatform.Core
dotnet sln add UknfCommunicationPlatform.Infrastructure
dotnet sln add UknfCommunicationPlatform.Tests.Unit
dotnet sln add UknfCommunicationPlatform.Tests.Integration
```

**Run the API:**
```bash
cd backend/UknfCommunicationPlatform.Api
dotnet run
```

The API will be available by default at:
- HTTPS: `https://localhost:7000`
- HTTP: `http://localhost:5000`
- Swagger UI: `https://localhost:7000/swagger`

**Verification:**
- Check that the API starts without errors
- Open Swagger UI in the browser
- Test the default endpoint (e.g., `/weatherforecast`)

**AI prompt for backend configuration:**
```
"Initialize an ASP.NET Core 9 Web API project with the following requirements:
- Clean Architecture (Api, Core, Infrastructure)
- Entity Framework Core with PostgreSQL
- Swagger/OpenAPI documentation
- CORS configured for http://localhost:4200
- JWT Authentication (prepared skeleton)
- Minimal API pattern
- Create first endpoint GET /api/health returning system status
- Add test projects (Unit, Integration)
- appsettings.json with separation for Development/Production"
```

### 3.2.3. First Working Endpoint

**Minimal health check endpoint:**

```csharp
// Program.cs
app.MapGet("/health", () => "Healthy")
.WithName("HealthCheck")
.WithTags("System");
```

**Alternative - more detailed response:**
```csharp
app.MapGet("/health", () => Results.Ok(new 
{
    Status = "Healthy",
    Timestamp = DateTime.UtcNow,
    Version = "1.0.0"
}))
.WithName("HealthCheck")
.WithTags("System")
.Produces<object>(StatusCodes.Status200OK);
```

**Test in browser/Postman:**
```
GET http://localhost:5000/health
```

**Expected response (simple version):**
```
Healthy
```

**Expected response (detailed version):**
```json
{
  "status": "Healthy",
  "timestamp": "2025-10-05T10:30:00Z",
  "version": "1.0.0"
}
```

**AI prompt for endpoint verification:**
```
"Verify the /health endpoint:
- Does it return status 200 OK?
- Does the response contain 'Healthy' text or a JSON object with status?
- Is it documented in Swagger?
- Does it work through both HTTP (localhost:5000) and HTTPS (localhost:7000)?
- Create an integration test for this endpoint"
```

### 3.2.4. Dockerization – Everything in One Command

**Docker structure:**
```
project-root/
├── docker-compose.yml
├── docker-compose.dev.yml
├── frontend/
│   └── Dockerfile
└── backend/
    └── Dockerfile
```

**Backend Dockerfile:**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080
EXPOSE 8081

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["UknfCommunicationPlatform.Api/UknfCommunicationPlatform.Api.csproj", "UknfCommunicationPlatform.Api/"]
COPY ["UknfCommunicationPlatform.Core/UknfCommunicationPlatform.Core.csproj", "UknfCommunicationPlatform.Core/"]
COPY ["UknfCommunicationPlatform.Infrastructure/UknfCommunicationPlatform.Infrastructure.csproj", "UknfCommunicationPlatform.Infrastructure/"]
RUN dotnet restore "UknfCommunicationPlatform.Api/UknfCommunicationPlatform.Api.csproj"
COPY . .
WORKDIR "/src/UknfCommunicationPlatform.Api"
RUN dotnet build "UknfCommunicationPlatform.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "UknfCommunicationPlatform.Api.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "UknfCommunicationPlatform.Api.dll"]
```

**Frontend Dockerfile:**
```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build -- --configuration production

FROM nginx:alpine
COPY --from=build /app/dist/uknf-project /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**docker-compose.yml (Production):**
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: uknf_db
      POSTGRES_USER: uknf_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U uknf_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=uknf_db;Username=uknf_user;Password=${DB_PASSWORD}
    ports:
      - "8080:8080"
    depends_on:
      postgres:
        condition: service_healthy

  frontend:
    build:
      context: ./frontend/uknf-project
      dockerfile: Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend

volumes:
  postgres_data:
```

**docker-compose.dev.yml (Development):**
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: uknf_db_dev
      POSTGRES_USER: dev_user
      POSTGRES_PASSWORD: dev_password
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ConnectionStrings__DefaultConnection=Host=postgres;Database=uknf_db_dev;Username=dev_user;Password=dev_password
    ports:
      - "5000:8080"
      - "5001:8081"
    volumes:
      - ./backend:/app
    depends_on:
      - postgres

  frontend:
    image: node:20-alpine
    working_dir: /app
    command: npm start
    volumes:
      - ./frontend/uknf-project:/app
      - /app/node_modules
    ports:
      - "4200:4200"
    environment:
      - API_URL=http://backend:8080

volumes:
  postgres_dev_data:
```

**Starting the environment:**

```bash
# Development (with hot-reload)
docker-compose -f docker-compose.dev.yml up

# Production
docker-compose up --build

# In background
docker-compose up -d

# Stop
docker-compose down

# Stop with volume removal (clean database)
docker-compose down -v
```

**Helper scripts:**

`dev-start.sh`:
```bash
#!/bin/bash
echo "Starting development environment..."
docker-compose -f docker-compose.dev.yml up --build
```

`dev-stop.sh`:
```bash
#!/bin/bash
echo "Stopping development environment..."
docker-compose -f docker-compose.dev.yml down
```

**Docker environment verification:**
```bash
# Check running containers
docker-compose ps

# Check logs
docker-compose logs -f backend
docker-compose logs -f frontend

# Check health check
curl http://localhost:8080/health
# Expected response: Healthy
```

**AI prompt for dockerization:**
```
"Create complete Docker configuration for the project:
- docker-compose.yml for production
- docker-compose.dev.yml for development with hot-reload
- Dockerfile for ASP.NET Core 9 (multi-stage build)
- Dockerfile for Angular 20 with nginx
- PostgreSQL 16 with health check
- Volumes for data persistence
- Environment variables in .env
- Startup scripts dev-start.sh and dev-stop.sh
- Nginx configuration for Angular SPA (routing support)
- Health check endpoints for all services
- Networking between containers
- README.md with startup instructions"
```

### 3.2.5. Publication Checklist

Before publishing the project, ensure that:

**Frontend:**
- [ ] Project initializes without errors (`ng new`)
- [ ] Development server starts (`ng serve`)
- [ ] Application opens in browser (localhost:4200)
- [ ] No errors in browser console
- [ ] No ESLint/TypeScript compilation errors
- [ ] Dockerfile builds correctly
- [ ] Production build works (`ng build --configuration production`)

**Backend:**
- [ ] Project compiles without errors (`dotnet build`)
- [ ] API starts (`dotnet run`)
- [ ] Swagger UI is accessible
- [ ] Endpoint /api/health returns response
- [ ] Unit tests pass (`dotnet test`)
- [ ] Dockerfile builds correctly
- [ ] Database connection works

**Docker:**
- [ ] `docker-compose up` starts all services
- [ ] Backend is accessible via localhost:8080
- [ ] Frontend is accessible via localhost:80
- [ ] Database initializes correctly
- [ ] Health checks for all services return OK
- [ ] Volumes preserve data after restart
- [ ] Logs are readable and show no errors

**Documentation:**
- [ ] README.md with startup instructions
- [ ] .env.example with required variables
- [ ] Swagger/OpenAPI documentation up to date
- [ ] Architecture diagrams (optional)

**AI prompt for verification:**
```
"Perform complete verification of project readiness for publication:
1. Check if all dependencies are installed
2. Run unit and integration tests
3. Build Docker images
4. Run docker-compose and test all endpoints
5. Check logs for errors and warnings
6. Verify documentation (README, swagger)
7. Check if .gitignore contains appropriate entries
8. Generate readiness report with list of met/unmet requirements"
```

### 3.2.6. Best Practices - Lessons Learned

**Recommendations:**
1. **Version your templates** - keep working templates in a separate repo
2. **Automate** - `init-project.sh` scripts for repeatability
3. **Document from the start** - README first, code later
4. **Health checks everywhere** - every service must have a /health endpoint
5. **Environment variables** - never hardcode credentials
6. **Docker first** - if it doesn't work in Docker, don't publish
7. **Smoke tests** - minimal tests before each commit

**Anti-patterns to avoid:**
- ❌ Publishing a project without a working endpoint
- ❌ No dockerization ("it works on my machine")
- ❌ Credentials in code
- ❌ No README with startup instructions
- ❌ Untested Dockerfile
- ❌ No health check endpoints
- ❌ Non-working docker-compose

3.3. Design
• Creating class/component schemas
• Architecture: microservices, monolith, DDD
• UML / diagrams (with conversion to code)

3.4. Coding
• Generating project skeleton
• Extending functionality step by step
• Integration with existing code (contextual AI hints)

3.5. Testing
• Generating unit and integration tests
• Test coverage – prompts for coverage analysis

3.6. Documentation
• Generating README, diagrams, changelogs
• Creating inline documentation (e.g., Javadoc, docstrings)

3.7. Refactoring and maintenance
• AI suggestions for refactoring
• Finding code smells and architectural errors
• Comparing versions and suggesting changes

