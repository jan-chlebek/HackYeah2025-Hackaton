# 5.1. Test Documentation

## Overview
This document explains the testing strategy, structure, and practices for the UKNF Communication Platform backend. We use a comprehensive testing approach with both unit tests and integration tests to ensure code quality, reliability, and maintainability.

---

## 1. Testing Architecture

### a. Test Projects Structure
The backend tests are organized into two main projects:

- **`UknfCommunicationPlatform.Tests.Unit`** - Unit tests for isolated component testing
  - Controllers (API endpoint logic)
  - Services (business logic)
  - Validators (input validation)
  - Authorization (permission/role handlers)
  - Configuration (Swagger, DI setup)

- **`UknfCommunicationPlatform.Tests.Integration`** - Integration tests for end-to-end scenarios
  - Controllers (full HTTP request/response flow)
  - Database operations (real PostgreSQL via Testcontainers)
  - Authentication/Authorization flows
  - Data consistency across modules

### b. Testing Frameworks and Tools
- **xUnit** - Main testing framework (familiar, extensible, supports parallel execution)
- **FluentAssertions** - Readable and expressive assertions
- **Moq** - Mocking framework for unit tests
- **Testcontainers** - Real PostgreSQL database for integration tests
- **In-Memory Database (EF Core)** - Fast unit tests without external dependencies
- **WebApplicationFactory** - ASP.NET Core integration testing infrastructure

---

## 2. Unit Tests

### Purpose
Unit tests verify individual components in isolation, with dependencies mocked. They are fast, reliable, and help pinpoint bugs quickly.

### Structure
- **Controllers**: Test API endpoint logic (validation, error handling, response mapping)
- **Services**: Test business logic (calculations, data transformations, orchestration)
- **Validators**: Test input validation rules (FluentValidation)
- **Authorization**: Test permission/role checks (policy handlers)

### Example: ReportsControllerTests
```csharp
public class ReportsControllerTests : IDisposable
{
    private readonly ApplicationDbContext _context;
    private readonly ReportsService _service;
    private readonly ReportsController _controller;
    
    public ReportsControllerTests()
    {
        // Use in-memory database for fast, isolated tests
        var options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        
        _context = new ApplicationDbContext(options);
        _service = new ReportsService(_context, Mock.Of<ILogger<ReportsService>>());
        _controller = new ReportsController(_service, Mock.Of<ILogger<ReportsController>>());
        
        SeedTestData();
    }
    
    [Fact]
    public async Task GetReports_WithFilters_ReturnsFilteredResults()
    {
        // Test implementation...
    }
}
```

### Best Practices
- **Arrange-Act-Assert (AAA)** pattern for clear test structure
- **One assertion per test** (or closely related assertions)
- **Descriptive test names** that explain what is being tested and expected outcome
- **In-memory database** with unique name per test class to avoid conflicts
- **Dispose pattern** to clean up resources after tests
- **Mock external dependencies** (logger, HTTP clients, etc.)

### Running Unit Tests
```bash
# Run all unit tests
dotnet test backend/UknfCommunicationPlatform.Tests.Unit

# Run specific test class
dotnet test backend/UknfCommunicationPlatform.Tests.Unit --filter "FullyQualifiedName~ReportsControllerTests"

# Run with verbose output
dotnet test backend/UknfCommunicationPlatform.Tests.Unit --logger "console;verbosity=detailed"
```

---

## 3. Integration Tests

### Purpose
Integration tests verify that multiple components work together correctly, including real database operations, HTTP requests, and authentication/authorization flows.

### Structure
- **Controllers**: Test full HTTP request/response cycle (routing, authentication, serialization, database operations)
- **End-to-End Scenarios**: Test complete workflows (create user → login → create message → verify in DB)
- **Database Operations**: Test that data is correctly persisted and retrieved
- **Authorization**: Test that role/permission checks work across the entire stack

### Example: MessagesControllerTests
```csharp
[Collection(nameof(DatabaseCollection))]
public class MessagesControllerTests : IClassFixture<TestDatabaseFixture>, IAsyncLifetime
{
    private readonly TestDatabaseFixture _factory;
    
    public MessagesControllerTests(TestDatabaseFixture factory, ITestOutputHelper output)
    {
        _factory = factory;
    }
    
    public async Task InitializeAsync()
    {
        // Reset test data before each test (keep seed data)
        await _factory.ResetTestDataAsync();
    }
    
    [Fact]
    public async Task CreateMessage_WithValidData_CreatesMessage()
    {
        // Arrange
        var client = _factory.CreateClient();
        var token = await _factory.GetAuthTokenAsync("admin@uknf.gov.pl", "Admin123!");
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
        
        var request = new CreateMessageRequest
        {
            Subject = "Test Message",
            Body = "Test body",
            RecipientId = 2,
            Priority = MessagePriority.High
        };
        
        // Act
        var response = await client.PostAsJsonAsync("/api/v1/messages", request);
        
        // Assert
        response.StatusCode.Should().Be(HttpStatusCode.Created);
        // Verify in database...
    }
}
```

### Best Practices
- **Real PostgreSQL** via Testcontainers for accurate database behavior
- **Shared test fixture** (TestDatabaseFixture) for efficient test execution
- **Collection fixture** to control parallel execution and resource sharing
- **Reset test data** between tests to ensure isolation
- **Keep seed data** (users, entities, roles) for authentication/authorization tests
- **Full HTTP cycle** including authentication, routing, validation, and persistence
- **Verify side effects** (check database state after operations)

### Running Integration Tests
```bash
# Run all integration tests (requires Docker for Testcontainers)
dotnet test backend/UknfCommunicationPlatform.Tests.Integration

# Run specific test class
dotnet test backend/UknfCommunicationPlatform.Tests.Integration --filter "FullyQualifiedName~MessagesControllerTests"

# Run with verbose output
dotnet test backend/UknfCommunicationPlatform.Tests.Integration --logger "console;verbosity=detailed"
```

---

## 4. Test Data Management

### Unit Tests
- **In-memory database** seeded per test class
- **Minimal data** - only what's needed for the specific test
- **Predictable IDs** - use known IDs for assertions (e.g., entityId = 1, userId = 2)

### Integration Tests
- **Real PostgreSQL** via Testcontainers
- **DatabaseSeeder.cs** provides consistent seed data (users, roles, entities, etc.)
- **Reset between tests** - remove test-created data, keep seed data
- **Authentication tokens** - use fixture methods to get valid JWT tokens

### Example Seed Data (from DatabaseSeeder.cs)
- **Users**: admin@uknf.gov.pl, internal staff, external entity users
- **Entities**: 17 supervised entities (banks, insurance, funds, etc.)
- **Roles**: Administrator, InternalUser, Supervisor, ExternalUser
- **Permissions**: users.read, users.write, entities.read, messages.read/write, reports.read/write

---

## 5. Running All Tests

### Scripts
We provide convenience scripts in the project root:

```bash
# Run all tests (unit + integration)
./run-tests.sh

# Run only backend tests
./run-tests-backend.sh

# Quick test run (parallel, less verbose)
./run-tests-quick.sh
```

### Manual Execution
```bash
# Run all backend tests
dotnet test backend/UknfCommunicationPlatform.Tests.Unit
dotnet test backend/UknfCommunicationPlatform.Tests.Integration

# Run with coverage (if configured)
dotnet test --collect:"XPlat Code Coverage"
```

### CI/CD Integration
- Tests run automatically on every pull request
- Integration tests require Docker (handled by CI environment)
- Test results are reported in PR checks
- Coverage reports are generated and tracked

---

## 6. Test Coverage

### Current Coverage (as of 2025-10-05)
- **Unit Tests**: ~20 test classes covering controllers, services, validators, authorization handlers
- **Integration Tests**: ~13 test classes covering end-to-end scenarios for main features
- **Total Tests**: ~150+ test cases

### Coverage Areas
- ✅ Authentication & Authorization (login, JWT, role/permission checks)
- ✅ Entities management (CRUD, filtering, validation)
- ✅ Reports (listing, filtering by entity/status/period)
- ✅ Messages (CRUD, attachments, read status, threading)
- ✅ Announcements (CRUD, recipients, read confirmations, attachments)
- ✅ Cases (CRUD, documents, history)
- ✅ File Library (upload, download, metadata, permissions)
- ✅ FAQ (questions, answers, ratings)
- ⚠️ Users management (partial - missing comprehensive CRUD tests)

### Areas Needing More Tests
- Users management controller (10 endpoints: CRUD, password, activation, deactivation, unlock)
- Messages controller (additional edge cases, error scenarios)
- Complex authorization scenarios (multi-role, entity-specific permissions)

---

## 7. Writing New Tests

### Step 1: Determine Test Type
- **Unit test** if testing logic in isolation (service methods, validators, utilities)
- **Integration test** if testing HTTP endpoints, database operations, or multi-component flows

### Step 2: Create Test Class
```csharp
// Unit test example
public class MyServiceTests : IDisposable
{
    private readonly ApplicationDbContext _context;
    private readonly MyService _service;
    
    public MyServiceTests()
    {
        var options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        _context = new ApplicationDbContext(options);
        _service = new MyService(_context, Mock.Of<ILogger<MyService>>());
    }
    
    public void Dispose() => _context.Dispose();
}

// Integration test example
[Collection(nameof(DatabaseCollection))]
public class MyControllerTests : IClassFixture<TestDatabaseFixture>, IAsyncLifetime
{
    private readonly TestDatabaseFixture _factory;
    
    public MyControllerTests(TestDatabaseFixture factory)
    {
        _factory = factory;
    }
    
    public async Task InitializeAsync()
    {
        await _factory.ResetTestDataAsync();
    }
    
    public Task DisposeAsync() => Task.CompletedTask;
}
```

### Step 3: Write Test Cases
- Use **descriptive names**: `MethodName_Scenario_ExpectedBehavior`
- Follow **AAA pattern**: Arrange, Act, Assert
- Use **FluentAssertions** for readable assertions
- Test **happy path** and **error scenarios**

### Step 4: Run and Verify
```bash
dotnet test --filter "FullyQualifiedName~MyServiceTests"
```

---

## 8. Troubleshooting Tests

### Common Issues

#### Integration tests fail with "Cannot connect to Docker"
- **Solution**: Ensure Docker is running and Testcontainers can access it
- Check Docker status: `docker ps`
- Restart Docker Desktop if needed

#### Tests fail with "Database already exists"
- **Solution**: Use unique database name per test class
- For unit tests: `Guid.NewGuid().ToString()` in DbContextOptions
- For integration tests: Use TestDatabaseFixture which manages DB lifecycle

#### Tests are slow
- **Solution**: 
  - Run unit tests separately (they're fast): `dotnet test backend/UknfCommunicationPlatform.Tests.Unit`
  - Use `run-tests-quick.sh` for parallel execution
  - Check if integration tests are properly resetting data (avoid full DB recreate)

#### Authentication fails in integration tests
- **Solution**: 
  - Verify seed data exists (users, roles)
  - Use `_factory.GetAuthTokenAsync()` for valid tokens
  - Check token expiration (tokens are valid for 1 hour)

---

## 9. Best Practices Summary

### General
- ✅ Write tests as you write code (TDD or test-after-development)
- ✅ Keep tests simple and focused (one concept per test)
- ✅ Use descriptive names (avoid Test1, Test2, etc.)
- ✅ Test both success and failure scenarios
- ✅ Clean up resources (Dispose pattern)

### Unit Tests
- ✅ Use in-memory database for speed
- ✅ Mock external dependencies
- ✅ Seed minimal data
- ✅ Test logic, not infrastructure

### Integration Tests
- ✅ Use real database (Testcontainers)
- ✅ Test full HTTP cycle
- ✅ Verify database state
- ✅ Test authentication/authorization
- ✅ Reset data between tests

---

## 10. Reference

### Related Documentation
- See `backend/UknfCommunicationPlatform.Tests.Unit/` for unit test examples
- See `backend/UknfCommunicationPlatform.Tests.Integration/` for integration test examples
- See `run-tests.sh` and related scripts for test execution
- See `.github/instructions/backend.instructions.md` for coding standards

### External Resources
- [xUnit documentation](https://xunit.net/)
- [FluentAssertions documentation](https://fluentassertions.com/)
- [Testcontainers documentation](https://testcontainers.com/)
- [ASP.NET Core integration testing](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests)

---

*Last updated: 2025-10-05*
